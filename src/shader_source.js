const VERTEX_SHADER_DEFAULT = [
'attribute vec2 position;								 	\n',
'uniform vec2 resolution;								 	\n',
'														 	\n',
'void main(void) {										 	\n',
'	vec2 zeroToOne = position / resolution;					\n',
'	vec2 zeroToTwo = zeroToOne * 2.0;					 	\n',
'	vec2 clipSpace = zeroToTwo - 1.0;					 	\n',
'														 	\n',
'	gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);	 	\n',
'}														 	\n',
].join('');

const FRAGMENT_SHADER_DEFAULT = [
'precision mediump float;									\n',
'															\n',
'uniform vec4 color;										\n',
'															\n',
'void main(void) {											\n',
'	gl_FragColor = color;									\n',
'}															\n',
].join('');

const VERTEX_SHADER_PIXEL_BUFFER = [
'attribute vec2 position;								 	\n',
'attribute vec4 a_color; 									\n',
'															\n',
'uniform vec2 resolution;								 	\n',
'															\n',
'varying vec4 v_color;										\n',
'														 	\n',
'void main(void) {										 	\n',
'	vec2 zeroToOne = position / resolution;					\n',
'	vec2 zeroToTwo = zeroToOne * 2.0;					 	\n',
'	vec2 clipSpace = zeroToTwo - 1.0;					 	\n',
'														 	\n',
'	gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);	 	\n',
'	v_color = a_color;										\n',
'}														 	\n',
].join('');

const FRAGMENT_SHADER_PIXEL_BUFFER = [
'precision mediump float;									\n',
'															\n',
'varying vec4 v_color;										\n',
'															\n',
'void main(void) {											\n',
'	gl_FragColor = v_color;									\n',
'}															\n',
].join('');

const VERTEX_SHADER_MULTIPLY_MATRIX = [
'attribute vec2 position;								 	\n',
'															\n',
'uniform vec2 resolution;								 	\n',
'															\n',
'void main(void) {										 	\n',
'	vec2 zeroToOne = position / resolution;					\n',
'	vec2 zeroToTwo = zeroToOne * 2.0;					 	\n',
'	vec2 clipSpace = zeroToTwo - 1.0;					 	\n',
'														 	\n',
'	gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);	 	\n',
'}														 	\n',
].join('');

const FRAGMENT_SHADER_MULTIPLY_MATRIX = [
'precision mediump float;																																		\n',
'																																								\n',
'uniform float matrixA[5];																																		\n',
'uniform float matrixB[5];																																		\n',
'																																								\n',
'void main(void) {																																				\n',
'	vec4 outputColor = vec4(0.0,0.0,0.0,0.0);																													\n',
'	float outputData = (matrixA[0]*matrixB[0])+(matrixA[1]*matrixB[1])+(matrixA[2]*matrixB[2])+(matrixA[3]*matrixB[3])+(matrixA[4]*matrixB[4]);					\n',
'	if (outputData > 5599.9999) { outputColor = vec4(155,99,99,99); }																							\n',
'	if (outputData < -5599.9999) { outputColor = vec4(255,99,99,99); }																							\n',
'																																								\n',
'	float tempData = abs(outputData);																															\n',
'	float dec = (tempData - floor(tempData)) * 10000.0;																											\n',
'	if (dec - floor(dec) < 0.5) { dec = floor(dec); }																											\n',
'	else { dec = ceil(dec); }																																	\n',
'	tempData = floor(tempData);																																	\n',
'	outputColor.g = tempData - (100.0 * floor(tempData/100.0));																									\n',
'	outputColor.r = floor(tempData / 100.0);																													\n',
'	outputColor.a = dec - (100.0 * floor(dec/100.0));																											\n',
'	outputColor.b = floor(dec / 100.0);																															\n',
'																																								\n',
'	if (outputData < 0.0) { outputColor.r += 200.0; }																											\n',
'	else { outputColor.r += 100.0; }																															\n',
'																																								\n',
'	outputColor /= 255.0;																																		\n',
'	gl_FragColor = outputColor;																																	\n',
'}																																								\n',
].join('');